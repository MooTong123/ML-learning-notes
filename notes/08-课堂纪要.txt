5.3 Boosting【**】
    1.boosting集成原理
        随着学习的积累从弱到强
    2.实现过程
        1.初始化训练数据权重，初始权重是相等的
        2.通过这个学习器，计算错误率
        3.计算这个学习期的投票权重
        4.对每个样本进行重新赋权
        5.重复前面1-4
        6.对构建后的最后的学习器进加权投票
    3.bagging集成与boosting集成的区别：
        数据方面：
            bagging:重新采样
            boosting:对数据进行权重调整
        投票方面：
            bagging:平权
            boosting:加权
        学习顺序方面：
            bagging:并行
            boosting:串行
        主要作用：
            bagging:过拟合
            boosting:欠拟合
    2 GBDT
        梯度提升决策树(GBDT Gradient Boosting Decision Tree)
        GBDT = 梯度下降 + Boosting + 决策树
    3.XGBoost
        XGBoost= 二阶泰勒展开+boosting+决策树+正则化

6.聚类算法
6.1 聚类算法简介
    1.聚类算法分类
        粗聚类
        细聚类
    2.定义
        一种典型的无监督学习算法，
        主要用于将相似的样本自动归到一个类别中
        计算样本和样本之间的相似性，一般使用欧式距离
6.2 聚类算法api初步使用
    1.api
        sklearn.cluster.KMeans(n_clusters=8)
        参数:
        n_clusters:开始的聚类中心数量
6.3 聚类算法实现流程【***】
    k-means其实包含两层内容：
        k -- 选几个中心店
        means -- 均值计算
    流程
        1、随机设置K个特征空间内的点作为初始的聚类中心
        2、对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别
        3、接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值）
        4、如果计算得出的新中心点与原中心点一样（质心不再移动），那么结束，否则重新进行第二步过程
    kmeans小结
        kmeans由于要计算质心到每一个样本的距离，所以其收敛速度比较慢
6.4 模型评估【**】
    0.sse
        误差平方和
        值越小越好
    1. 肘部法
        ​ 下降率突然变缓时即认为是最佳的k值
    2. SC系数
        ​ 取值为[-1, 1]，其值越大越好
    3. CH系数
        ​ 分数s高则聚类效果越好
        CH需要达到的目的：
            用尽量少的类别聚类尽量多的样本，同时获得较好的聚类效果。
6.5 算法优化【***】
    1.k_means
        优点：
            简单，容易理解
        缺点：
            特别人容易陷入到局部最优解
    2.Canopy
        通过绘制同心圆，进行k值选择筛选
        需要确定同心圆的半径t1,t2
    3.K-means++
        距离平方进行求解
        保证下一个质心到当前质心，距离最远
    4.二分k-means
        通过误差平方和，设置阈值，然后进行划分
    5.k-medoids
        和kmeans选取中心点的方式不同
        通过从当前点选择中心点（质心）进行判断
    6.kernel kmeans【了解】
        映射到高维空间
    7.ISODATA【了解】
        动态聚类
        可以更改k值的大小
    8.Mini-batch K-Means【了解】
        大数据集分批聚类

6.6 特征降维【***】
    1.定义
        就是改变特征值，选择哪列保留，哪列删除
        目标是得到一组”不相关“的主变量
    2.降维的两种方式
        特征选择
        主成分分析（可以理解一种特征提取的方式）
    3.特征选择
        定义：提出数据中的冗余变量
        方法：
            Filter(过滤式)：主要探究特征本身特点、特征与特征和目标值之间关联
                方差选择法：低方差特征过滤
                相关系数
            Embedded (嵌入式)：算法自动选择特征（特征与目标值之间的关联）
                决策树:信息熵、信息增益
                正则化：L1、L2
                深度学习：卷积等
    4.低方差特征过滤
        把方差比较小的某一列进行剔除
        api:
            sklearn.feature_selection.VarianceThreshold(threshold = 0.0)
                删除所有低方差特征
                注意，参数threshold一定要进行值的指定
    5.相关系数
        主要实现方式：
            皮尔逊相关系数
            斯皮尔曼相关系数
        5.1 皮尔逊相关系数
            通过具体值的大小进行计算
            相对复杂
            api:
                from scipy.stats import pearsonr
                返回值，越接近|1|，相关性越强；越接近0，相关性越弱
        5.2 斯皮尔曼相关系数
            通过等级差进行计算
            比上一个简单
            api:
                from scipy.stats import spearmanr
                返回值，越接近|1|，相关性越强；越接近0，相关性越弱
    6.pca
        定义：
            高维数据转换为低维数据，然后产生了新的变量
        api:
            sklearn.decomposition.PCA(n_components=None)
                n_components
                    整数 -- 表示降低到几维
                    小数 -- 保留百分之多少的信息
6.7 案例：探究用户对物品类别的喜好【***】
    1.获取数据
    2.数据基本处理
    2.1 合并表格
    2.2 交叉表合并
    2.3 数据截取
    3.特征工程 — pca
    4.机器学习（k-means）
    5.模型评估

